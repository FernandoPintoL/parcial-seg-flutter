// Script de prueba basado en el ejemplo proporcionado
// Ejecutar en la consola del navegador

console.log('üß™ Probando sistema de arrastre simplificado...');

// Funci√≥n para encontrar elementos
function findElements() {
    const elements = document.querySelectorAll('.unified-widget-element');
    console.log(`üìä Elementos encontrados: ${elements.length}`);
    
    if (elements.length === 0) {
        console.log('‚ùå No hay elementos para probar');
        return [];
    }
    
    return Array.from(elements);
}

// Funci√≥n para verificar estado de selecci√≥n
function checkSelectionState() {
    const selectedElements = document.querySelectorAll('.selected-widget');
    const allElements = document.querySelectorAll('.unified-widget-element');
    
    console.log('üìä Estado de selecci√≥n:');
    console.log(`   - Elementos totales: ${allElements.length}`);
    console.log(`   - Elementos seleccionados: ${selectedElements.length}`);
    
    selectedElements.forEach((element, index) => {
        console.log(`   - Elemento seleccionado ${index + 1}: ${element.dataset.elementId}`);
        console.log(`     * Tipo: ${element.dataset.elementType}`);
        console.log(`     * Z-index: ${window.getComputedStyle(element).zIndex}`);
        console.log(`     * Cursor: ${window.getComputedStyle(element).cursor}`);
    });
    
    return selectedElements;
}

// Funci√≥n para probar selecci√≥n (como en el ejemplo)
function testSelection(element) {
    console.log('üéØ Probando selecci√≥n de elemento:', element.dataset.elementId);
    
    // Verificar estado inicial
    const wasSelected = element.classList.contains('selected-widget');
    console.log(`   - Estado inicial: ${wasSelected ? 'seleccionado' : 'no seleccionado'}`);
    
    // Simular clic
    const clickEvent = new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window
    });
    
    element.dispatchEvent(clickEvent);
    
    // Verificar estado despu√©s del clic
    setTimeout(() => {
        const isSelected = element.classList.contains('selected-widget');
        console.log(`   - Estado despu√©s del clic: ${isSelected ? 'seleccionado' : 'no seleccionado'}`);
        
        if (isSelected) {
            const resizeHandle = element.querySelector('.resize-handle');
            console.log(`   - Handle de redimensionar: ${resizeHandle ? 'visible' : 'NO visible'}`);
            
            if (resizeHandle) {
                const handleStyle = window.getComputedStyle(resizeHandle);
                console.log(`   - Handle z-index: ${handleStyle.zIndex}`);
                console.log(`   - Handle cursor: ${handleStyle.cursor}`);
            }
        }
    }, 100);
}

// Funci√≥n para probar arrastre (como en el ejemplo)
function testDrag(element) {
    console.log('üñ±Ô∏è Probando arrastre de elemento:', element.dataset.elementId);
    
    const rect = element.getBoundingClientRect();
    const startX = rect.left + 50;
    const startY = rect.top + 25;
    
    console.log('üìç Posici√≥n inicial:', { x: rect.left, y: rect.top });
    console.log('üéØ Punto de inicio:', { x: startX, y: startY });
    
    // Mousedown
    const mousedownEvent = new MouseEvent('mousedown', {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: startX,
        clientY: startY
    });
    
    element.dispatchEvent(mousedownEvent);
    
    // Verificar estado despu√©s del mousedown
    setTimeout(() => {
        const isDragging = element.classList.contains('is-dragging');
        console.log(`   - Estado despu√©s del mousedown: ${isDragging ? 'arrastrando' : 'no arrastrando'}`);
        
        if (isDragging) {
            const style = window.getComputedStyle(element);
            console.log(`   - Cursor durante arrastre: ${style.cursor}`);
            console.log(`   - Z-index durante arrastre: ${style.zIndex}`);
        }
        
        // Mousemove (arrastrar)
        setTimeout(() => {
            const mousemoveEvent = new MouseEvent('mousemove', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: startX + 100,
                clientY: startY + 50
            });
            
            document.dispatchEvent(mousemoveEvent);
            
            // Verificar posici√≥n durante el arrastre
            setTimeout(() => {
                const newRect = element.getBoundingClientRect();
                console.log('üìç Posici√≥n durante arrastre:', { x: newRect.left, y: newRect.top });
                
                const moved = newRect.left !== rect.left || newRect.top !== rect.top;
                console.log(`‚úÖ Elemento ${moved ? 'se movi√≥' : 'NO se movi√≥'}`);
                
                // Mouseup
                const mouseupEvent = new MouseEvent('mouseup', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                
                document.dispatchEvent(mouseupEvent);
                
                // Verificar posici√≥n final
                setTimeout(() => {
                    const finalRect = element.getBoundingClientRect();
                    console.log('üìç Posici√≥n final:', { x: finalRect.left, y: finalRect.top });
                    
                    const finalMoved = finalRect.left !== rect.left || finalRect.top !== rect.top;
                    console.log(`‚úÖ Elemento ${finalMoved ? 'se movi√≥ finalmente' : 'NO se movi√≥ finalmente'}`);
                    
                    // Verificar estado final
                    const finalDragging = element.classList.contains('is-dragging');
                    console.log(`   - Estado final: ${finalDragging ? 'arrastrando' : 'no arrastrando'}`);
                }, 100);
            }, 100);
        }, 100);
    }, 100);
}

// Funci√≥n para probar redimensionar
function testResize(element) {
    console.log('üìè Probando redimensionar elemento:', element.dataset.elementId);
    
    const resizeHandle = element.querySelector('.resize-handle');
    if (!resizeHandle) {
        console.log('‚ùå No se encontr√≥ handle de redimensionar');
        return;
    }
    
    const rect = element.getBoundingClientRect();
    const handleRect = resizeHandle.getBoundingClientRect();
    
    console.log('üìç Tama√±o inicial:', { width: rect.width, height: rect.height });
    console.log('üìç Posici√≥n del handle:', { x: handleRect.left, y: handleRect.top });
    
    // Mousedown en el handle
    const mousedownEvent = new MouseEvent('mousedown', {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: handleRect.left + 5,
        clientY: handleRect.top + 5
    });
    
    resizeHandle.dispatchEvent(mousedownEvent);
    
    // Mousemove para redimensionar
    setTimeout(() => {
        const mousemoveEvent = new MouseEvent('mousemove', {
            bubbles: true,
            cancelable: true,
            view: window,
            clientX: handleRect.left + 50,
            clientY: handleRect.top + 30
        });
        
        document.dispatchEvent(mousemoveEvent);
        
        // Verificar tama√±o despu√©s del mousemove
        setTimeout(() => {
            const newRect = element.getBoundingClientRect();
            console.log('üìç Tama√±o durante redimensionar:', { width: newRect.width, height: newRect.height });
            
            const resized = newRect.width !== rect.width || newRect.height !== rect.height;
            console.log(`‚úÖ Elemento ${resized ? 'se redimension√≥' : 'NO se redimension√≥'}`);
            
            // Mouseup
            const mouseupEvent = new MouseEvent('mouseup', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            
            document.dispatchEvent(mouseupEvent);
            
            // Verificar tama√±o final
            setTimeout(() => {
                const finalRect = element.getBoundingClientRect();
                console.log('üìç Tama√±o final:', { width: finalRect.width, height: finalRect.height });
                
                const finalResized = finalRect.width !== rect.width || finalRect.height !== rect.height;
                console.log(`‚úÖ Elemento ${finalResized ? 'se redimension√≥ finalmente' : 'NO se redimension√≥ finalmente'}`);
            }, 100);
        }, 100);
    }, 100);
}

// Funci√≥n para verificar superposiciones
function checkOverlaps() {
    console.log('üîç Verificando superposiciones...');
    
    const elements = document.querySelectorAll('.unified-widget-element');
    const overlaps = [];
    
    elements.forEach((element1, i) => {
        const rect1 = element1.getBoundingClientRect();
        const zIndex1 = parseInt(window.getComputedStyle(element1).zIndex) || 0;
        
        elements.forEach((element2, j) => {
            if (i === j) return;
            
            const rect2 = element2.getBoundingClientRect();
            const zIndex2 = parseInt(window.getComputedStyle(element2).zIndex) || 0;
            
            // Verificar si hay superposici√≥n
            const overlapX = rect1.left < rect2.right && rect1.right > rect2.left;
            const overlapY = rect1.top < rect2.bottom && rect1.bottom > rect2.top;
            
            if (overlapX && overlapY) {
                overlaps.push({
                    element1: element1.dataset.elementId,
                    element2: element2.dataset.elementId,
                    zIndex1,
                    zIndex2,
                    overlap: true
                });
            }
        });
    });
    
    if (overlaps.length > 0) {
        console.log('‚ö†Ô∏è Superposiciones detectadas:');
        overlaps.forEach(overlap => {
            console.log(`   - ${overlap.element1} (z: ${overlap.zIndex1}) y ${overlap.element2} (z: ${overlap.zIndex2})`);
        });
    } else {
        console.log('‚úÖ No hay superposiciones detectadas');
    }
    
    return overlaps;
}

// Funci√≥n principal de prueba
function runSimpleDragTest() {
    console.log('üöÄ Ejecutando prueba de arrastre simplificado...');
    
    const elements = findElements();
    if (elements.length === 0) return;
    
    // Paso 1: Verificar estado inicial
    console.log('\nüìã Paso 1: Estado inicial');
    checkSelectionState();
    checkOverlaps();
    
    // Paso 2: Probar selecci√≥n del primer elemento
    console.log('\nüìã Paso 2: Probando selecci√≥n');
    const firstElement = elements[0];
    testSelection(firstElement);
    
    // Paso 3: Verificar selecci√≥n
    setTimeout(() => {
        console.log('\nüìã Paso 3: Verificando selecci√≥n');
        checkSelectionState();
        
        // Paso 4: Probar arrastre
        console.log('\nüìã Paso 4: Probando arrastre');
        testDrag(firstElement);
        
        // Paso 5: Probar redimensionar
        setTimeout(() => {
            console.log('\nüìã Paso 5: Probando redimensionar');
            testResize(firstElement);
            
            // Paso 6: Verificar estado final
            setTimeout(() => {
                console.log('\nüìã Paso 6: Estado final');
                checkSelectionState();
                checkOverlaps();
                
                console.log('\n‚úÖ Prueba completada');
            }, 500);
        }, 1000);
    }, 500);
}

// Funci√≥n para probar un elemento espec√≠fico
function testSpecificElement(elementId) {
    const element = document.querySelector(`[data-element-id="${elementId}"]`);
    if (!element) {
        console.error('‚ùå Elemento no encontrado:', elementId);
        return;
    }
    
    console.log('üéØ Probando elemento espec√≠fico:', elementId);
    
    // Probar selecci√≥n
    testSelection(element);
    
    // Probar arrastre
    setTimeout(() => {
        testDrag(element);
        
        // Probar redimensionar
        setTimeout(() => {
            testResize(element);
        }, 1000);
    }, 1000);
}

// Exportar funciones
window.runSimpleDragTest = runSimpleDragTest;
window.testSpecificElement = testSpecificElement;
window.findElements = findElements;
window.checkSelectionState = checkSelectionState;
window.testSelection = testSelection;
window.testDrag = testDrag;
window.testResize = testResize;
window.checkOverlaps = checkOverlaps;

console.log('üìã Funciones de prueba disponibles:');
console.log('- runSimpleDragTest(): Prueba completa de arrastre simplificado');
console.log('- testSpecificElement("id"): Probar elemento espec√≠fico');
console.log('- findElements(): Encontrar elementos');
console.log('- checkSelectionState(): Verificar estado de selecci√≥n');
console.log('- testSelection(element): Probar selecci√≥n');
console.log('- testDrag(element): Probar arrastre');
console.log('- testResize(element): Probar redimensionar');
console.log('- checkOverlaps(): Verificar superposiciones');

console.log('üí° Para ejecutar la prueba completa, usa: runSimpleDragTest()'); 